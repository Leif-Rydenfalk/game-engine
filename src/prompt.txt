// voxel.wgsl

const PI = 3.14159265359;
const betaR = vec3f(5.5e-6, 13.0e-6, 22.4e-6);
const betaM = vec3f(21e-6);
const hR = 7994.0;
const hM = 1200.0;
const earth_radius = 6360e3;
const atmosphere_radius = 6420e3;
const sun_power = 10.0;
const g = 0.76;
const k = 1.55 * g - 0.55 * (g * g * g);
const num_samples = 16;
const num_samples_light = 8;

struct Ray {
    origin: vec3f,
    direction: vec3f,
};

struct Sphere {
    origin: vec3f,
    radius: f32,
    material: i32,
};

struct IsectResult {
    hit: bool,
    t0: f32,
    t1: f32,
};

const atmosphere = Sphere(vec3f(0.0, 0.0, 0.0), atmosphere_radius, 0);

fn isect_sphere(ray: Ray, sphere: Sphere) -> IsectResult {
    let rc = sphere.origin - ray.origin;
    let radius2 = sphere.radius * sphere.radius;
    let tca = dot(rc, ray.direction);
    let d2 = dot(rc, rc) - tca * tca;
    if d2 > radius2 {
        return IsectResult(false, 0.0, 0.0);
    }
    let thc = sqrt(radius2 - d2);
    let t0 = tca - thc;
    let t1 = tca + thc;
    return IsectResult(true, t0, t1);
}

fn rayleigh_phase_func(mu: f32) -> f32 {
    return 3.0 * (1.0 + mu * mu) / (16.0 * PI);
}

fn henyey_greenstein_phase_func(mu: f32) -> f32 {
    return (1.0 - g * g) / (4.0 * PI * pow(1.0 + g * g - 2.0 * g * mu, 1.5));
}

fn get_sun_light(ray: Ray, optical_depthR: ptr<function, f32>, optical_depthM: ptr<function, f32>) -> bool {
    let isect = isect_sphere(ray, atmosphere);
    if !isect.hit {
        return false;
    }
    let t1 = isect.t1;
    let march_step = t1 / f32(num_samples_light);
    var march_pos = 0.0;
    for (var i = 0; i < num_samples_light; i = i + 1) {
        let s = ray.origin + ray.direction * (march_pos + 0.5 * march_step);
        let height = length(s) - earth_radius;
        if height < 0.0 {
            return false;
        }
        *optical_depthR += exp(-height / hR) * march_step;
        *optical_depthM += exp(-height / hM) * march_step;
        march_pos += march_step;
    }
    return true;
}

fn get_incident_light(ray: Ray, sun_dir: vec3f) -> vec3f {
    let isect = isect_sphere(ray, atmosphere);
    if !isect.hit {
        return vec3f(0.0);
    }
    let t1 = isect.t1;
    let march_step = t1 / f32(num_samples);
    let mu = dot(ray.direction, sun_dir);
    let phaseR = rayleigh_phase_func(mu);
    let phaseM = henyey_greenstein_phase_func(mu);
    var optical_depthR = 0.0;
    var optical_depthM = 0.0;
    var sumR = vec3f(0.0);
    var sumM = vec3f(0.0);
    var march_pos = 0.0;
    for (var i = 0; i < num_samples; i = i + 1) {
        let s = ray.origin + ray.direction * (march_pos + 0.5 * march_step);
        let height = length(s) - earth_radius;
        let hr = exp(-height / hR) * march_step;
        let hm = exp(-height / hM) * march_step;
        optical_depthR += hr;
        optical_depthM += hm;
        let light_ray = Ray(s, sun_dir);
        var optical_depth_lightR = 0.0;
        var optical_depth_lightM = 0.0;
        let overground = get_sun_light(light_ray, &optical_depth_lightR, &optical_depth_lightM);
        if overground {
            let tau = betaR * (optical_depthR + optical_depth_lightR) + betaM * 1.1 * (optical_depthM + optical_depth_lightM);
            let attenuation = exp(-tau);
            sumR += hr * attenuation;
            sumM += hm * attenuation;
        }
        march_pos += march_step;
    }
    var c = sun_power * (sumR * phaseR * betaR + sumM * phaseM * betaM);
    c = pow(c, vec3<f32>(1.5));
    c = c / (1.0 + c);
    c = pow(c, vec3<f32>(1.0 / 1.5));
    c = mix(c, c * c * (3.0 - 2.0 * c), vec3<f32>(1.0));
    c = pow(c, vec3<f32>(1.3, 1.20, 1.0));
    c = pow(c, vec3<f32>(0.7 / 2.2));
    return c;
}

struct Settings {
    max: f32,
    r_inner: f32,
    r: f32,
    max_height: f32,
    max_water_height: f32,
    water_height: f32,
    tunnel_radius: f32,
    surface_factor: f32,
    camera_speed: f32,
    camera_time_offset: f32,
    voxel_level: i32,
    voxel_size: f32,
    steps: i32,
    max_dist: f32,
    min_dist: f32,
    eps: f32,
    
    light_color: vec4f,
    light_direction: vec4f,
    
    show_normals: i32,
    show_steps: i32,
    visualize_distance_field: i32,

    _padding: i32,
};

@group(0) @binding(0) var<uniform> camera: CameraUniform;
@group(1) @binding(0) var rgb_noise_texture: texture_2d<f32>;
@group(1) @binding(1) var gray_cube_noise_texture: texture_3d<f32>; 
@group(1) @binding(2) var grain_texture: texture_2d<f32>; 
@group(1) @binding(3) var dirt_texture: texture_2d<f32>;  
@group(1) @binding(4) var pebble_texture: texture_2d<f32>;  
@group(1) @binding(5) var terrain_sampler: sampler; // Must use repeat mode
@group(2) @binding(0) var<uniform> settings: Settings;

struct CameraUniform {
    view_proj: mat4x4<f32>,
    inv_view_proj: mat4x4<f32>,
    view: mat4x4<f32>,
    camera_position: vec3f,
    time: f32,
};

struct VertexInput {
    @location(0) position: vec3f,
    @location(1) tex_uv: vec2f,
    @location(2) normal: vec3f,
};

struct VertexOutput {
    @builtin(position) position: vec4f,
    @location(0) tex_uv: vec2f,
    @location(1) normal: vec3f,
    @location(2) world_position: vec3f,
};

struct HitInfo {
    is_hit: bool,
    t: f32,
    n: vec3f,
    id: vec3f,
    i: i32,
};

// Utility Functions
fn smin(d1: f32, d2: f32, k: f32) -> f32 {
    let h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) - k * h * (1.0 - h);
}

fn smax(d1: f32, d2: f32, k: f32) -> f32 {
    let h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) + k * h * (1.0 - h);
}

fn hash13(p: vec3f) -> f32 {
    var p3 = fract(p * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

// Added hash23 function for film grain effect
fn hash23(p: vec3f) -> vec2f {
    var p3 = fract(p * vec3f(0.1031, 0.1030, 0.0973));
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx + p3.yz) * p3.zy);
}

fn triplanarLod(p: vec3f, n: vec3f, k: f32, tex_index: i32, lod: f32) -> vec3f {
    let n_pow = pow(abs(n), vec3f(k));
    let n_norm = n_pow / dot(n_pow, vec3f(1.0));
    var col = vec3f(0.0);
    if tex_index == 0 {
        col = textureSampleLevel(rgb_noise_texture, terrain_sampler, p.yz, lod).rgb * n_norm.x + textureSampleLevel(rgb_noise_texture, terrain_sampler, p.xz, lod).rgb * n_norm.y + textureSampleLevel(rgb_noise_texture, terrain_sampler, p.xy, lod).rgb * n_norm.z;
    } else if tex_index == 2 {
        col = textureSampleLevel(grain_texture, terrain_sampler, p.yz, lod).rgb * n_norm.x + textureSampleLevel(grain_texture, terrain_sampler, p.xz, lod).rgb * n_norm.y + textureSampleLevel(grain_texture, terrain_sampler, p.xy, lod).rgb * n_norm.z;
    } else if tex_index == 3 {
        col = textureSampleLevel(dirt_texture, terrain_sampler, p.yz, lod).rgb * n_norm.x + textureSampleLevel(dirt_texture, terrain_sampler, p.xz, lod).rgb * n_norm.y + textureSampleLevel(dirt_texture, terrain_sampler, p.xy, lod).rgb * n_norm.z;
    }
    return col;
}

fn map(p: vec3f) -> f32 {
    var d: f32 = settings.max_dist;
    let sc: f32 = 0.3;
    // Terrain generation remains the same
    let q: vec3f = sc * p / 32.0 - vec3f(0.003, -0.006, 0.0);
    d = textureSample(gray_cube_noise_texture, terrain_sampler, q * 1.0).r * 0.5;
    d += textureSample(gray_cube_noise_texture, terrain_sampler, q * 2.0 + vec3f(0.3, 0.3, 0.3)).r * 0.25;
    d += textureSample(gray_cube_noise_texture, terrain_sampler, q * 4.0 + vec3f(0.7, 0.7, 0.7)).r * 0.125;
    var tp = smoothstep(50.0, -6.0, p.y);
    tp = tp * tp;
    d = (d / 0.875 - settings.surface_factor) / sc;
    d = smax(d, p.y - settings.max_height, 0.6);
    
    // let camera_pos = camera.camera_position;
    // let camera_distance = length(p - camera_pos);
    
    // // Remove terrain to close to the camera
    // d = smax(d, settings.min_dist - camera_distance, 0.3);

    return d;
}

fn grad(p: vec3f) -> vec3f {
    let e = vec2f(0.0, 0.1);
    return (map(p) - vec3f(
        map(p - e.yxx),
        map(p - e.xyx),
        map(p - e.xxy)
    )) / e.y;
}

fn get_voxel_pos(p: vec3f, s: f32) -> vec3f {
    return (floor(p / s) + 0.5) * s;
}

fn trace(ro: vec3f, rd: vec3f, tmax: f32) -> HitInfo {
    let s = settings.voxel_size;
    let sd = s * sqrt(3.0);
    let ird = 1.0 / rd;
    let srd = sign(ird);
    let ard = abs(ird);
    var t = 0.0;
    var vpos = get_voxel_pos(ro, s);
    var voxel = false;
    var vi = 0;
    var prd = vec3f(0.0);
    for (var i = 0; i < settings.steps; i = i + 1) {
        let pos = ro + rd * t;
        let d = map(select(pos, vpos, voxel));
        if !voxel {
            t += d;
            if d < sd {
                vpos = get_voxel_pos(ro + rd * max(t - sd, 0.0), s);
                voxel = true;
                vi = 0;
            }
        } else {
            let n = (ro - vpos) * ird;
            let k = ard * s * 0.5;
            let t2 = -n + k;
            let tF = min(min(t2.x, t2.y), t2.z);
            var nrd = vec3f(0.0);
            if t2.x <= t2.y && t2.x <= t2.z {
                nrd = vec3f(srd.x, 0.0, 0.0);
            } else if t2.y <= t2.z {
                nrd = vec3f(0.0, srd.y, 0.0);
            } else {
                nrd = vec3f(0.0, 0.0, srd.z);
            }
            if d < 0.0 {
                return HitInfo(true, t, -prd, vpos, i);
            } else if d > sd && vi > 2 {
                voxel = false;
                t = tF + sd;
                continue;
            }
            vpos += nrd * s;
            prd = nrd;
            t = tF + settings.eps;
            vi += 1;
        }
        if t >= tmax || (rd.y > 0.0 && pos.y > settings.max_height) {
            return HitInfo(false, t, vec3f(0.0), vec3f(0.0), i);
        }
    }
    return HitInfo(false, tmax, vec3f(0.0), vec3f(0.0), settings.steps);
}

fn triplanar(p: vec3f, n: vec3f, k: f32, tex_index: i32) -> vec3f {
    let n_pow = pow(abs(n), vec3f(k));
    let n_norm = n_pow / dot(n_pow, vec3f(1.0));
    var col = vec3f(0.0);
    if tex_index == 0 {
        col = textureSample(rgb_noise_texture, terrain_sampler, p.yz).rgb * n_norm.x + textureSample(rgb_noise_texture, terrain_sampler, p.xz).rgb * n_norm.y + textureSample(rgb_noise_texture, terrain_sampler, p.xy).rgb * n_norm.z;
    } else if tex_index == 2 {
        col = textureSample(grain_texture, terrain_sampler, p.yz).rgb * n_norm.x + textureSample(grain_texture, terrain_sampler, p.xz).rgb * n_norm.y + textureSample(grain_texture, terrain_sampler, p.xy).rgb * n_norm.z;
    } else if tex_index == 3 {
        col = textureSample(dirt_texture, terrain_sampler, p.yz).rgb * n_norm.x + textureSample(dirt_texture, terrain_sampler, p.xz).rgb * n_norm.y + textureSample(dirt_texture, terrain_sampler, p.xy).rgb * n_norm.z;
    }
    return col;
}

fn getBiome(pos: vec3f) -> vec2f {
    let snow = textureSample(dirt_texture, terrain_sampler, pos.xz * 0.00015).r;
    let desert = textureSample(dirt_texture, terrain_sampler, vec2f(0.55) - pos.zx * 0.00008).g;
    return vec2f(smoothstep(0.67, 0.672, desert), smoothstep(0.695, 0.7, snow));
}

fn getAlbedo(vpos: vec3f, gn: vec3f, lod: f32) -> vec3f {
    var alb = vec3f(1.0) - triplanarLod(vpos * 0.08, gn, 4.0, 2, lod);
    alb *= alb;
    var alb2 = vec3f(1.0) - triplanarLod(vpos * 0.08, gn, 4.0, 3, lod);
    alb2 *= alb2;
    let k = triplanarLod(vpos * 0.0005, gn, 4.0, 0, 0.0).r;
    let wk = smoothstep(settings.max_water_height, settings.max_water_height + 0.5, vpos.y);
    let top = smoothstep(0.3, 0.7, gn.y);
    alb = alb * 0.95 * vec3f(1.0, 0.7, 0.65) + 0.05;
    alb = mix(alb, alb2 * vec3f(0.55, 1.0, 0.1), top * wk);
    alb = mix(alb, smoothstep(vec3f(0.0), vec3f(1.0), alb2), smoothstep(0.3, 0.25, k) * (1.0 - top));
    let biome = getBiome(vpos);
    var snow = alb2 * 0.8 + 0.2 * vec3f(0.25, 0.5, 1.0);
    snow = mix(snow, vec3f(0.85, 0.95, 1.0), top * wk * 0.5);
    alb = mix(alb, clamp(vec3f(1.0, 0.95, 0.9) - alb2 * 0.65, vec3f(0.0), vec3f(1.0)), biome.x);
    alb = mix(alb, snow * 2.0, biome.y);
    var dcol = vec3f(0.8, 0.55, 0.35);
    dcol = mix(dcol, vec3f(0.8, 0.65, 0.4), biome.x);
    dcol = mix(dcol, vec3f(0.2, 0.6, 0.8), biome.y);
    alb = mix(alb, alb * dcol, (1.0 - wk) * mix(1.0 - smoothstep(0.3, 0.25, k), 1.0, max(biome.x, biome.y)));
    return alb;
}

fn shade(pos: vec3f, ldir: vec3f, lod: f32, hit: HitInfo) -> vec3f {
    let vpos = hit.id;
    let g = grad(vpos);
    let gn = g / length(g);
    let n = hit.n;
    var dif = max(dot(n, ldir), 0.0);
    if dif > 0.0 {
        let hitL = trace(pos + n * 1e-3, ldir, 12.0);
        if hitL.is_hit { dif = 0.0; }
    }
    var col = getAlbedo(vpos, gn, lod);
    let ao = smoothstep(-0.08, 0.04, map(pos) / length(grad(pos)));
    let hao = smoothstep(settings.water_height - 12.0, settings.water_height, pos.y);
    col *= dot(abs(n), vec3f(0.8, 1.0, 0.9));
    // Fixed: Added missing * operators
    col *= (dif * 0.6 + 0.4) * settings.light_color.rgb;
    col *= (ao * 0.6 + 0.4) * (hao * 0.6 + 0.4);
    return col;
}

fn shade2(pos: vec3f, ldir: vec3f, lod: f32, hit: HitInfo) -> vec3f {
    let vpos = hit.id;
    let g = grad(vpos);
    let gn = g / length(g);
    let n = hit.n;
    let dif = max(dot(n, ldir), 0.0);

    var col = getAlbedo(vpos, gn, lod);
    let ao = smoothstep(-0.08, 0.04, map(pos) / length(grad(pos)));
    let hao = smoothstep(settings.water_height - 12.0, settings.water_height, pos.y);

    col *= dot(abs(n), vec3f(0.8, 1.0, 0.9));
    col *= (dif * 0.6 + 0.4) * settings.light_color.rgb;
    col *= ao * 0.6 + 0.4;
    col *= hao * 0.6 + 0.4;

    return col;
}

fn ACESFilm(x: vec3f) -> vec3f {
    let a = 2.51; let b = 0.03; let c = 2.43; let d = 0.59; let e = 0.14;
    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), vec3f(0.0), vec3f(1.0));
}

@vertex
fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
    let positions = array<vec2f, 4>(
        vec2f(-1.0, -1.0), vec2f(1.0, -1.0),
        vec2f(-1.0, 1.0), vec2f(1.0, 1.0)
    );
    let tex_coords = array<vec2f, 4>(
        vec2f(0.0, 0.0), vec2f(1.0, 0.0),
        vec2f(0.0, 1.0), vec2f(1.0, 1.0)
    );
    var output: VertexOutput;
    output.position = vec4f(positions[vertex_index], 0.0, 1.0);
    output.tex_uv = tex_coords[vertex_index];
    output.normal = vec3f(0.0, 0.0, 1.0);
    output.world_position = vec3f(0.0);
    return output;
}

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4f {
    let ro = camera.camera_position;
    let ndc = vec4f(input.tex_uv * 2.0 - 1.0, 1.0, 1.0);
    let world_pos = camera.inv_view_proj * ndc;
    let rd = normalize(world_pos.xyz / world_pos.w - ro);

    let sun_dir = normalize(settings.light_direction.xyz);

    var sky_ro = ro + vec3f(0.0, earth_radius + 1.0, 0.0);

    if settings.visualize_distance_field != 0 {
        let pos = ro + rd * 10.0;
        let d = map(pos);
        return vec4f(vec3f(d * 0.1 + 0.5), 1.0);
    }

    let hit = trace(ro, rd, settings.max_dist);
    var col = vec3f(0.0);
    var t = hit.t;
    
    if hit.is_hit {
        let pos = ro + rd * hit.t;
        let lod = clamp(log2(distance(ro, hit.id)) - 2.0, 0.0, 6.0);
        col = shade(pos, sun_dir, lod, hit);
    } else {
        col = get_incident_light(Ray(sky_ro, rd), sun_dir);
        t = settings.max_dist;
    }

    let pt = -(ro.y - settings.water_height) / rd.y;
    if ((pt > 0.0 && pt < t)) || ro.y < settings.water_height {
        if !hit.is_hit {
            let biome = getBiome(ro + rd * pt);
            col = mix(vec3f(0.5, 0.8, 1.0), vec3f(1.0, 0.85, 0.6), biome.x);
        }

        let biome = getBiome(ro + rd * pt);
        var wcol = vec3f(0.3, 0.8, 1.0);
        wcol = mix(wcol, vec3f(0.4, 0.9, 0.8), biome.x);
        wcol = mix(wcol, vec3f(0.1, 0.7, 0.9), biome.y);

        let wabs = vec3f(0.1, 0.7, 0.9);

        var adjusted_pt = pt;
        if ro.y < settings.water_height && pt < 0.0 {
            adjusted_pt = settings.max_dist;
        }

        let wpos = ro + rd * adjusted_pt;

        let e = 0.001;
        let wnstr = 1500.0;
        let wo = vec2f(1.0, 0.8) * camera.time * 0.01;
        let wuv = wpos.xz * 0.08 + wo;
        let wh = textureSample(grain_texture, terrain_sampler, wuv).r;
        let whdx = textureSample(grain_texture, terrain_sampler, wuv + vec2f(e, 0.0)).r;
        let whdy = textureSample(grain_texture, terrain_sampler, wuv + vec2f(0.0, e)).r;
        let wn = normalize(vec3f(wh - whdx, e * wnstr, wh - whdy));
        let wref = reflect(rd, wn);

        var rcol = vec3f(0.0);
        if ro.y > settings.water_height {
            let hitR = trace(wpos + vec3f(0.0, 0.01, 0.0), wref, 15.0);
            let lod = clamp(log2(distance(ro, hitR.id)) - 2.0, 0.0, 6.0);
            
            if hitR.is_hit {
                rcol = shade2(wpos, sun_dir, lod, hitR);
            } else {
                let w_sky_ro = wpos + vec3f(0.0, earth_radius, 0.0);
                rcol = get_incident_light(Ray(wpos, wref), sun_dir);
            }
        }
        
        // Specular highlight
        let spec = pow(max(dot(wref, sun_dir), 0.0), 50.0);
        
        // Fresnel reflection factor
        let r0 = 0.35;
        var fre = r0 + (1.0 - r0) * pow(max(dot(rd, wn), 0.0), 5.0);

        if rd.y < 0.0 && ro.y < settings.water_height {
            fre = 0.0;
        }
        
        // Water absorption
        let abt = select(t - pt, min(t, pt), ro.y < settings.water_height);
        col *= exp(-abt * (1.0 - wabs) * 0.1);

        if pt < t {
            col = mix(col, wcol * (rcol + spec), fre);
            
            // Foam effect
            let wp = wpos + wn * vec3f(1.0, 0.0, 1.0) * 0.2;
            let wd = map(wp) / length(grad(wp));
            let foam = sin((wd - camera.time * 0.03) * 60.0);
            let foam_mask = smoothstep(0.22, 0.0, wd + foam * 0.03 + (wh - 0.5) * 0.12);
            col = mix(col, col + vec3f(1.0), foam_mask * 0.4);
        }
    }
    
    if settings.show_normals != 0 {
        col = hit.n;
    }

    if settings.show_steps != 0 {
        col = vec3f(f32(hit.i) / f32(settings.steps));
    }

    return vec4f(col, 1.0);
}

// Shadertoy reference:

#define VOLUME_TEXTURES
#define NOISE_TEXTURES

const float PI	 	= 3.141592;
#define EPSILON_NRM (0.1 / iResolution.x)

// Cloud parameters
const float EARTH_RADIUS = 6300e3;
const float CLOUD_START = 800.0;
const float CLOUD_HEIGHT = 600.0;
const vec3 SUN_POWER = vec3(1.0,0.9,0.6) * 750.;
const vec3 LOW_SCATTER = vec3(1.0, 0.7, 0.5);

// Ocean parameter
// Procedural generation mostly from TDM https://www.shadertoy.com/view/Ms2SD1
const int ITER_GEOMETRY = 3;
const int ITER_FRAGMENT = 5;
const float SEA_HEIGHT = 0.6;
const float SEA_CHOPPY = 4.0;
const float SEA_FREQ = 0.16;
const vec3 SEA_BASE = 8.0*vec3(0.1,0.21,0.35);

// Cube parameters
const vec3 albedo = vec3(0.95, 0.16, 0.015);

// Noise generation functions (by iq)
float hash( float n )
{
    return fract(sin(n)*43758.5453);
}

float hash( vec2 p ) {
    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);
}

float noise( in vec3 x )
{
    vec3 p = floor(x);
    vec3 f = fract(x);
    f = f*f*(3.0-2.0*f);
#ifdef VOLUME_TEXTURES    
    return textureLod(iChannel2, (p+f+0.5)/32.0, 0.0).x;
#else
	vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;
	vec2 rg = textureLod( iChannel1, (uv+0.5)/256.0, 0.0).yx;
	return mix( rg.x, rg.y, f.z );
#endif
}

float noise( in vec2 p ) {
    vec2 i = floor( p );
    vec2 f = fract( p );	
	f = f*f*(3.0-2.0*f);
#ifdef NOISE_TEXTURES
    return textureLod(iChannel3, (i+f+vec2(0.5))/64.0, 0.0).x*2.0 -1.0;
#else    
    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), 
                     hash( i + vec2(1.0,0.0) ), f.x),
                mix( hash( i + vec2(0.0,1.0) ), 
                     hash( i + vec2(1.0,1.0) ), f.x), f.y);
#endif
}

float fbm( vec3 p )
{
    mat3 m = mat3( 0.00,  0.80,  0.60,
              -0.80,  0.36, -0.48,
              -0.60, -0.48,  0.64 );    
    float f;
    f  = 0.5000*noise( p ); p = m*p*2.02;
    f += 0.2500*noise( p ); p = m*p*2.03;
    f += 0.1250*noise( p );
    return f;
}

float intersectSphere(vec3 origin, vec3 dir, vec3 spherePos, float sphereRad)
{
	vec3 oc = origin - spherePos;
	float b = 2.0 * dot(dir, oc);
	float c = dot(oc, oc) - sphereRad*sphereRad;
	float disc = b * b - 4.0 * c;
	if (disc < 0.0)
		return -1.0;    
    float q = (-b + ((b < 0.0) ? -sqrt(disc) : sqrt(disc))) / 2.0;
	float t0 = q;
	float t1 = c / q;
	if (t0 > t1) {
		float temp = t0;
		t0 = t1;
		t1 = temp;
	}
	if (t1 < 0.0)
		return -1.0;
    
    return (t0 < 0.0) ? t1 : t0;
}

float clouds(vec3 p, out float cloudHeight, bool fast)
{
#if 1
    float atmoHeight = length(p - vec3(0.0, -EARTH_RADIUS, 0.0)) - EARTH_RADIUS;
    cloudHeight = clamp((atmoHeight-CLOUD_START)/(CLOUD_HEIGHT), 0.0, 1.0);
    p.z += iTime*10.3;
    float largeWeather = clamp((textureLod(iChannel0, -0.00005*p.zx, 0.0).x-0.18)*5.0, 0.0, 2.0);
    p.x += iTime*8.3;
    float weather = largeWeather*max(0.0, textureLod(iChannel0, 0.0002*p.zx, 0.0).x-0.28)/0.72;
    weather *= smoothstep(0.0, 0.5, cloudHeight) * smoothstep(1.0, 0.5, cloudHeight);
    float cloudShape = pow(weather, 0.3+1.5*smoothstep(0.2, 0.5, cloudHeight));
    if(cloudShape <= 0.0)
        return 0.0;    
    p.x += iTime*12.3;
	float den= max(0.0, cloudShape-0.7*fbm(p*.01));
    if(den <= 0.0)
        return 0.0;
    
    if(fast)
    	return largeWeather*0.2*min(1.0, 5.0*den);

    p.y += iTime*15.2;
    den= max(0.0, den-0.2*fbm(p*0.05));
    return largeWeather*0.2*min(1.0, 5.0*den);
#else
    return 0.0;
#endif
}

// From https://www.shadertoy.com/view/4sjBDG
float numericalMieFit(float costh)
{
    // This function was optimized to minimize (delta*delta)/reference in order to capture
    // the low intensity behavior.
    float bestParams[10];
    bestParams[0]=9.805233e-06;
    bestParams[1]=-6.500000e+01;
    bestParams[2]=-5.500000e+01;
    bestParams[3]=8.194068e-01;
    bestParams[4]=1.388198e-01;
    bestParams[5]=-8.370334e+01;
    bestParams[6]=7.810083e+00;
    bestParams[7]=2.054747e-03;
    bestParams[8]=2.600563e-02;
    bestParams[9]=-4.552125e-12;
    
    float p1 = costh + bestParams[3];
    vec4 expValues = exp(vec4(bestParams[1] *costh+bestParams[2], bestParams[5] *p1*p1, bestParams[6] *costh, bestParams[9] *costh));
    vec4 expValWeight= vec4(bestParams[0], bestParams[4], bestParams[7], bestParams[8]);
    return dot(expValues, expValWeight);
}

float lightRay(vec3 p, float phaseFunction, float dC, float mu, vec3 sun_direction, float cloudHeight, bool fast)
{
    int nbSampleLight = fast ? 7 : 20;
	float zMaxl         = 600.;
    float stepL         = zMaxl/float(nbSampleLight);
    
    float lighRayDen = 0.0;    
    p += sun_direction*stepL*hash(dot(p, vec3(12.256, 2.646, 6.356)) + iTime);
    for(int j=0; j<nbSampleLight; j++)
    {
        float cloudHeight;
        lighRayDen += clouds( p + sun_direction*float(j)*stepL, cloudHeight, fast);
    }    
    if(fast)
    {
        return (0.5*exp(-0.4*stepL*lighRayDen) + max(0.0, -mu*0.6+0.3)*exp(-0.02*stepL*lighRayDen))*phaseFunction;
    }
    float scatterAmount = mix(0.008, 1.0, smoothstep(0.96, 0.0, mu));
    float beersLaw = exp(-stepL*lighRayDen)+0.5*scatterAmount*exp(-0.1*stepL*lighRayDen)+scatterAmount*0.4*exp(-0.02*stepL*lighRayDen);
    return beersLaw * phaseFunction * mix(0.05 + 1.5*pow(min(1.0, dC*8.5), 0.3+5.5*cloudHeight), 1.0, clamp(lighRayDen*0.4, 0.0, 1.0));
}

float udRoundBox( vec3 p, vec3 b, float r )
{
    return length(max(abs(p)-b,0.0))-r;
}

mat3 cubeForm = mat3(1.0);
float Yelevation = 0.0;
float map( in vec3 pos )
{
    pos *= cubeForm;
    pos.y += Yelevation;
    
    pos.y += 3.66;
    pos.z += 0.4;
    pos *= 0.35;
        
    float res = udRoundBox(  pos-vec3( 0.0,1.25, 0.0), vec3(0.15), 0.01 );
    res = min( res, udRoundBox(  pos-vec3( 0.33,1.25, 0.0), vec3(0.15), 0.01 ) );
    res = min( res, udRoundBox(  pos-vec3( 0.33,1.25, 0.33), vec3(0.15), 0.01 ) );
    res = min( res, udRoundBox(  pos-vec3( 0.0,1.25, 0.33), vec3(0.15), 0.01 ) );
    
    res = min( res, udRoundBox(  pos-vec3( 0.0,1.58, 0.0), vec3(0.15), 0.01 ) );
    res = min( res, udRoundBox(  pos-vec3( 0.0,1.58, 0.33), vec3(0.15), 0.01 ) );
    res = min( res, udRoundBox(  pos-vec3( 0.33,1.58, 0.0), vec3(0.15), 0.01 ) ); 
    return res;
}

float sea_octave(vec2 uv, float choppy) {
    uv += noise(uv);        
    vec2 wv = 1.0-abs(sin(uv));
    vec2 swv = abs(cos(uv));    
    wv = mix(wv,swv,wv);
    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);
}

float mapWater(vec3 p, int steps, bool cube) {
    float freq = SEA_FREQ;
    float amp = SEA_HEIGHT;
    float choppy = SEA_CHOPPY;
    vec2 uv = p.xz; uv.x *= 0.75;
    
    float d, h = 0.0;
    const float SEA_SPEED = 0.8;
    const mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);
    float seaTime = (1.0 + iTime * SEA_SPEED);
    for(int i = 0; i < steps; i++)
    {        
    	d = sea_octave((uv+seaTime)*freq,choppy);
    	d += sea_octave((uv-seaTime)*freq,choppy);
        h += d * amp;        
    	uv *= octave_m; freq *= 1.9; amp *= 0.22;
        choppy = mix(choppy,1.0,0.2);
    }
    if(!cube)
        return p.y -h;
    
    return p.y - h - 0.2*exp(-max(0.0, 23.0*map(p)));
}

float Schlick (float f0, float VoH )
{
	return f0+(1.-f0)*pow(1.0-VoH,5.0);
}

vec3 skyRay(vec3 org, vec3 dir, vec3 sun_direction, bool fast)
{
    const float ATM_START = EARTH_RADIUS+CLOUD_START;
	const float ATM_END = ATM_START+CLOUD_HEIGHT;
    
    int nbSample = fast ? 13 : 35;   
    vec3 color = vec3(0.0);
	float distToAtmStart = intersectSphere(org, dir, vec3(0.0, -EARTH_RADIUS, 0.0), ATM_START);
    float distToAtmEnd = intersectSphere(org, dir, vec3(0.0, -EARTH_RADIUS, 0.0), ATM_END);
    vec3 p = org + distToAtmStart * dir;    
    float stepS = (distToAtmEnd-distToAtmStart) / float(nbSample);    
    float T = 1.;    
    float mu = dot(sun_direction, dir);
    float phaseFunction = numericalMieFit(mu);
    p += dir*stepS*hash(dot(dir, vec3(12.256, 2.646, 6.356)) + iTime);
    if(dir.y > 0.015)
	for(int i=0; i<nbSample; i++)
	{        
        float cloudHeight;
		float density = clouds(p, cloudHeight, fast);
		if(density>0.)
		{
			float intensity = lightRay(p, phaseFunction, density, mu, sun_direction, cloudHeight, fast);        
            vec3 ambient = (0.5 + 0.6*cloudHeight)*vec3(0.2, 0.5, 1.0)*6.5 + vec3(0.8) * max(0.0, 1.0-2.0*cloudHeight);
            vec3 radiance = ambient + SUN_POWER*intensity;
            radiance*=density;			
            color += T*(radiance - radiance * exp(-density * stepS)) / density;   // By Seb Hillaire                  
            T *= exp(-density*stepS);            
			if( T <= 0.05)
				break;
        }
		p += dir*stepS;
	}
        
    if(!fast)
    {
        vec3 pC = org + intersectSphere(org, dir, vec3(0.0, -EARTH_RADIUS, 0.0), ATM_END+1000.0)*dir;
    	color += T*vec3(3.0)*max(0.0, fbm(vec3(1.0, 1.0, 1.8)*pC*0.002)-0.4);
    }
	vec3 background = 6.0*mix(vec3(0.2, 0.52, 1.0), vec3(0.8, 0.95, 1.0), pow(0.5+0.5*mu, 15.0))+mix(vec3(3.5), vec3(0.0), min(1.0, 2.3*dir.y));
    if(!fast) 	background += T*vec3(1e4*smoothstep(0.9998, 1.0, mu));
    color += background * T;
    
    return color;
}

float D_GGX(in float r, in float NoH, in vec3 h)
{
    float a = NoH * r;
    float k = r / ((1.0 - NoH * NoH) + a * a);
    return k * k * (1.0 / PI);
}

float castRay( in vec3 ro, in vec3 rd, in float tmin)
{
    float tmax = 10.0;   
#if 1
    float maxY = 3.0;
    float minY = -1.0;
    // bounding volume
    float tp1 = (minY-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (maxY-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>maxY ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif    
    float t = tmin;
    for( int i=0; i<100; i++ )
    {
	    float precis = 0.0005*t;
	    float res = map( ro+rd*t );
        if( res<precis || t>tmax ) break;
        t += res;
    }
    if( t>tmax ) return -1.;
    return t;
}


float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<14; i++ )
    {
		float h = map( ro + rd*t );
        res = min( res, 8.*h/t );
        t += clamp( h, 0.08, 0.25 );
        if( res<0.001 || t>tmax ) break;
    }
    return max(0.0, res);
}

vec3 calcNormal( in vec3 pos)
{
    vec2 e = vec2(1.0,-1.0)*EPSILON_NRM;
    return normalize( e.xyy*map( pos + e.xyy ) + 
					  e.yyx*map( pos + e.yyx ) + 
					  e.yxy*map( pos + e.yxy ) + 
					  e.xxx*map( pos + e.xxx ) );
}

float calcAO( in vec3 pos, in vec3 nor )
{
	float sca = 10.2;
    float hr = 0.05;  
    float dd = map( nor * 0.15 + pos ); 
    return clamp( 1.0 + (dd-hr)*sca, 0.0, 1.0 );     
}

vec3 renderCubeFast(in vec3 p, in vec3 dir, in vec3 sun_direction, in float res)
{
    vec3 pos = p + res*dir;
    vec3 nor = calcNormal( pos );
    float NoL = max(0.0, dot(sun_direction, nor));    
    vec3 color = 0.6*NoL*SUN_POWER*albedo/PI; // diffuse
    //color *= softshadow(pos, sun_direction, 0.001, 2.0); // Shadow
    color += albedo * vec3(0.3, 0.6, 1.0)* 35.0 * (0.75 + 0.25*nor.y); // skylight
    return color;
}

float HenyeyGreenstein(float mu, float inG)
{
	return (1.-inG * inG)/(pow(1.+inG*inG - 2.0 * inG*mu, 1.5)*4.0* PI);
}

vec3 getSeaColor(in vec3 p, in vec3 N, in vec3 sun_direction, in vec3 dir, in vec3 dist, in float mu, in float cloudShadow)
{    
    vec3 L = normalize(vec3(0.0)+reflect(dir, N));
    vec3 V = -dir;
	float NoV = clamp(abs(dot(N, V))+1e-5,0.0, 1.0);
    float NoL = max(0.0, dot(N, L));
    float VoH = max(0.0, dot(V, normalize(V+L)));    
    float fresnel = Schlick(0.02, NoV);    
    float cubeRes = castRay(p, L, 0.0001);
    vec3 reflection = skyRay(p, L, sun_direction, true);
    if(cubeRes != -1.)
        reflection = renderCubeFast(p, L, sun_direction, cubeRes);    
    vec3 color = mix(cloudShadow*SEA_BASE, reflection, fresnel);    
    float subsurfaceAmount = 12.0*HenyeyGreenstein(mu, 0.5);
    const vec3 SEA_WATER_COLOR = 0.6*vec3(0.8,0.9,0.6);
    color += subsurfaceAmount * SEA_WATER_COLOR * max(0.0, 1.0+p.y - 0.6*SEA_HEIGHT);    
    if(cubeRes == -1.)
    {
    	vec3 H = normalize(V+sun_direction);
        float NoL = max(0.0, dot(N, sun_direction));
        float roughness = 0.05;
    	color += LOW_SCATTER*0.4*vec3(NoL/PI*fresnel*SUN_POWER*D_GGX(roughness, max(0.0, dot(N, H)), H));
    }
    color += 9.0*max(0.0, smoothstep(0.35, 0.6, p.y - SEA_HEIGHT) * N.x); // Foam
    float foamShadow = max(0.0, dot(sun_direction.xz, normalize(p.xz-vec2(0.0, 0.0))));
    color += foamShadow*2.5*smoothstep(0.06+0.06*N.z,0.0,map(p))*max(0.0, N.y); // Foam at cube entry
    return color;
}

vec3 getNormalWater(vec3 p, float eps) {   
    vec3 n;
    n.y = mapWater(p, ITER_FRAGMENT, true);    
    n.x = mapWater(vec3(p.x+eps,p.y,p.z), ITER_FRAGMENT, true) - n.y;
    n.z = mapWater(vec3(p.x,p.y,p.z+eps), ITER_FRAGMENT, true) - n.y;
    n.y = eps;  
    return normalize(n);
}

float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  
    float tm = 0.0;
    float tx = 1e8;    
    float hx = mapWater(ori + dir * tx, ITER_GEOMETRY, true);
    if(hx > 0.0) return tx;   
    float hm = mapWater(ori + dir * tm, ITER_GEOMETRY, true);    
    float tmid = 0.0;
    for(int i = 0; i < 8; i++)
    {
        tmid = mix(tm,tx, hm/(hm-hx));                   
        p = ori + dir * tmid;                   
    	float hmid = mapWater(p, ITER_GEOMETRY, true);
		if(hmid < 0.0)
        {
        	tx = tmid;
            hx = hmid;
        } else
        {
            tm = tmid;
            hm = hmid;
        }
    }
    return tmid;
}

vec3 worldReflection(vec3 org, vec3 dir, vec3 sun_direction)
{    
    if(castRay(org, dir, 0.05) != -1. || dir.y < 0.0)
        return vec3(0.0);
    
    return skyRay(org, dir, sun_direction, true);
}

vec3 renderCube(vec3 p, vec3 dir, vec3 sun_direction, float res)
{
    vec3 pos = p + res*dir;
    vec3 nor = calcNormal( pos );
    float occ = calcAO( pos, nor );
    float NoL = max(0.0, dot(sun_direction, nor));
    float sunShadow = softshadow(pos, sun_direction, 0.001, 2.0);
    vec3 color = 0.6*NoL*SUN_POWER*albedo* sunShadow/PI; // diffuse
    color += albedo*occ * vec3(0.3, 0.6, 1.0)* 35.0 * (0.75 + 0.25*nor.y); // skylight
    color += Schlick(0.04, max(0.0, dot(nor, -dir)))*worldReflection(pos, reflect(dir, nor), sun_direction)*max(0.0, occ-0.7)/0.7; // specular
    return color;
}

void setupCubeForm()
{
    const float EPS_EL = 0.9;
    float elevationX = mapWater(vec3(EPS_EL, 0.0, 0.0), 2, false);
    float elevationY = mapWater(vec3(-EPS_EL, 0.0, -EPS_EL), 2,false);
    float elevationZ = mapWater(vec3(-EPS_EL, 0.0, EPS_EL), 2,false);
    
    float waveRotX = elevationX - (elevationY + elevationZ) * 0.5;
    float waveRotZ = ((elevationZ - elevationX)+(elevationX - elevationY))*0.5;
    vec2 euler = vec2(0.3- waveRotZ, -0.15- waveRotX);    
    vec2 s = sin(euler);
    vec2 c = cos(euler);
    
    mat3 rotX = mat3(
        1.0, 0.0, 0.0,
        0.0, c.x, s.x,
        0.0, -s.x, c.x
    );
      
    mat3 rotZ = mat3(
        c.y, s.y, 0.0,
        -s.y, c.y, 0.0,
        0.0, 0.0, 1.0
    );
    
    cubeForm = inverse(rotX*rotZ);  
    Yelevation = 0.333*(elevationX + elevationY + elevationZ);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
	vec2 q = fragCoord.xy / iResolution.xy;
    vec2 v = -1.0 + 2.0*q;
    v.x *= iResolution.x/ iResolution.y;
    vec2 mo = iMouse.xy / iResolution.xy;
    
    float camRot = -7.0*mo.x;
    vec3 org = (vec3(6.0*cos(camRot), mix(2.2, 10.0, mo.y), 6.0*sin(camRot)));    
	vec3 ta = vec3(0.0, mix(1.2, 12.0, mo.y), 0.0);
    
    if (iMouse.z < 0.)
    {
        vec3 offset = -0.4*vec3(-5.7, 0.0, 1.6);
        ta = vec3(0.0, 2.9, 0.0)+offset;
        org = vec3(1.6, 3.1, 5.7)+offset;
    }
    
    vec3 ww = normalize( ta - org);
    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));
    vec3 vv = normalize(cross(ww,uu));
    vec3 dir = normalize( v.x*uu + v.y*vv + 1.4*ww );
	vec3 color=vec3(.0);
    vec3 sun_direction = normalize( vec3(0.6,0.45,-0.8) );
	float fogDistance = intersectSphere(org, dir, vec3(0.0, -EARTH_RADIUS, 0.0), EARTH_RADIUS);
    float mu = dot(sun_direction, dir);
    
    setupCubeForm();
    float cubeRes = castRay(org, dir, 2.0);
    
    // Sky
    if(fogDistance == -1. && cubeRes == -1.)
    {
        color = skyRay(org, dir, sun_direction, false); 
        fogDistance = intersectSphere(org, dir, vec3(0.0, -EARTH_RADIUS, 0.0), EARTH_RADIUS+160.0);
    }
    else if(fogDistance == -1. && cubeRes != -1.)
    {
        color.xyz = renderCube(org, dir, sun_direction, cubeRes);
        fogDistance = cubeRes;
    }
    else // water
    {
        vec3 waterHitPoint;
    	heightMapTracing(org,dir,waterHitPoint);         
    	vec3 dist = waterHitPoint - org;
    	vec3 n = getNormalWater(waterHitPoint, dot(dist,dist) * EPSILON_NRM);
        float cloudShadow= 1.0-textureLod(iChannel0, waterHitPoint.xz*0.008-vec2(0.0, 0.03*iTime), 7.0).x;        
   	 	color = getSeaColor(waterHitPoint,n,sun_direction,dir,dist, mu, cloudShadow); 
        
        if(cubeRes != -1.)
        {
            float distT = length(dist);
            if(cubeRes > distT) // Under the water cube
            {
                vec3 refr = refract(dir, n, 0.75);
            	cubeRes = castRay(waterHitPoint, refr, 0.001);            	
                if(cubeRes != -1.)
                {
                    vec3 cube = renderCube(waterHitPoint, refr, sun_direction, cubeRes); 
        			float fresnel = 1.0 - Schlick(0.04, max(0.0, dot(n, -dir)));
            		color.xyz += fresnel * (cube.xyz *vec3(0.7, 0.8, 0.9)*exp(-0.01*vec3(60.0, 15.0, 1.0)*max(0.0, cubeRes)) - SEA_BASE * cloudShadow);
                }
            }
            else
            {
                color = renderCube(org, dir, sun_direction, cubeRes);
            }            
            fogDistance = cubeRes;
        }
    }  
    
    float fogPhase = 0.5*HenyeyGreenstein(mu, 0.7)+0.5*HenyeyGreenstein(mu, -0.6);    
    fragColor = vec4(mix(fogPhase*0.1*LOW_SCATTER*SUN_POWER+10.0*vec3(0.55, 0.8, 1.0), color, exp(-0.0003*fogDistance)), 1.0);
}

iChannel0 = pebble texture
iChannel1 = rgb noise
iChannel2 = gray noise cube
iChannel3 = gray perlin noise

