@group(0) @binding(0) var t_input: texture_2d<f32>;
@group(0) @binding(1) var t_output: texture_storage_2d<rgba16float, write>;

fn calc_offset(octave: f32) -> vec2<f32> {
    let padding = vec2<f32>(10.0 / f32(textureDimensions(t_input).x), 10.0 / f32(textureDimensions(t_input).y));
    var offset = vec2<f32>(0.0);
    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);
    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;
    offset.y += min(1.0, floor(octave / 3.0)) * 0.35;
    return offset;
}

fn grab(coord: vec2<f32>, octave: f32, offset: vec2<f32>, oversampling: i32) -> vec3<f32> {
    let scale = exp2(octave);
    let sample_coord = (coord + offset) * scale;
    if (sample_coord.x < 0.0 || sample_coord.x > 1.0 || sample_coord.y < 0.0 || sample_coord.y > 1.0) {
        return vec3<f32>(0.0);
    }
    var color = vec3<f32>(0.0);
    let tex_size = vec2<f32>(textureDimensions(t_input));
    for (var i = 0; i < oversampling; i = i + 1) {
        for (var j = 0; j < oversampling; j = j + 1) {
            let off = (vec2<f32>(f32(i), f32(j)) / tex_size + vec2<f32>(0.0) / tex_size) * scale / f32(oversampling);
            color += textureLoad(t_input, vec2<i32>(sample_coord * tex_size + off * tex_size), 0).rgb;
        }
    }
    return color / f32(oversampling * oversampling);
}

@compute @workgroup_size(8, 8)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
    let dims = textureDimensions(t_input);
    let uv = vec2<f32>(f32(id.x) / f32(dims.x), f32(id.y) / f32(dims.y));
    var color = vec3<f32>(0.0);
    color += grab(uv, 1.0, vec2<f32>(0.0, 0.0), 1);
    color += grab(uv, 2.0, calc_offset(1.0), 4);
    color += grab(uv, 3.0, calc_offset(2.0), 8);
    color += grab(uv, 4.0, calc_offset(3.0), 16);
    textureStore(t_output, vec2<i32>(id.xy), vec4<f32>(color, 1.0));
}