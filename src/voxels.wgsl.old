// voxel.wgsl

// Constants
const MAX_HEIGHT: f32 = 5.0;
const MAX_WATER_HEIGHT: f32 = -2.2;
const WATER_HEIGHT: f32 = MAX_WATER_HEIGHT;
const TUNNEL_RADIUS: f32 = 1.1;
const SURFACE_FACTOR: f32 = 0.42;
const CAMERA_SPEED: f32 = -1.5;
const CAMERA_TIME_OFFSET: f32 = 0.0;
const VOXEL_LEVEL: i32 = 2; // Match Shadertoy default
const VOXEL_SIZE: f32 = exp2(-f32(VOXEL_LEVEL));
const STEPS: i32 = 512;
const MAX_DIST: f32 = 60.0;
const EPS: f32 = 0.0001;
const PI: f32 = 3.14159265359;
const ldir_unnormalized: vec3f = vec3f(0.85, 1.2, 0.8);
const lcol: vec3f = vec3f(1.0, 0.9, 0.75) * 2.0;

// Bindings
@group(0) @binding(0) var<uniform> camera: CameraUniform;
@group(1) @binding(0) var noise0_texture: texture_2d<f32>; // iChannel0: Basic noise
@group(1) @binding(1) var noise1_texture: texture_3d<f32>; // iChannel1: 3D noise
@group(1) @binding(2) var grain_texture: texture_2d<f32>;  // iChannel2: Grain texture
@group(1) @binding(3) var dirt_texture: texture_2d<f32>;   // iChannel3: Dirt texture
@group(1) @binding(4) var terrain_sampler: sampler;

// Camera uniform structure
struct CameraUniform {
    view_proj: mat4x4<f32>,
    inv_view_proj: mat4x4<f32>,
    view: mat4x4<f32>,
    camera_position: vec3f,
    _padding: f32,
};

// Vertex input/output structures
struct VertexInput {
    @location(0) position: vec3f,
    @location(1) tex_uv: vec2f,
    @location(2) normal: vec3f,
};

struct VertexOutput {
    @builtin(position) position: vec4f,
    @location(0) tex_uv: vec2f,
    @location(1) normal: vec3f,
    @location(2) world_position: vec3f,
};

// Hit information structure
struct HitInfo {
    is_hit: bool,
    t: f32,
    n: vec3f,
    id: vec3f,
    i: i32,
};

// Utility functions
fn smax(d1: f32, d2: f32, k: f32) -> f32 {
    let h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) + k * h * (1.0 - h);
}

fn get_path(t: f32) -> vec2f {
    let x = (cos(t * 0.35 * CAMERA_SPEED) + sin(t * 0.25 * CAMERA_SPEED) * 0.5) * 0.55;
    let y = (sin(t * 0.25 * CAMERA_SPEED) + cos(t * 0.2 * CAMERA_SPEED) * 0.4) * 0.35;
    return vec2f(x, y);
}

fn map(p: vec3f) -> f32 {
    let sc = 0.3;
    let uvw = sc * p / 32.0 - vec3f(0.003, -0.006, 0.0);
    
    var d = 0.0;
    d += textureSample(noise1_texture, terrain_sampler, uvw * 1.0).r * 0.5;
    d += textureSample(noise1_texture, terrain_sampler, uvw * 2.0 + vec3f(0.3, 0.3, 0.3)).r * 0.25;
    d += textureSample(noise1_texture, terrain_sampler, uvw * 4.0 + vec3f(0.7, 0.7, 0.7)).r * 0.125;
    
    let tp = smoothstep(50.0, -6.0, p.y);
    let tp2 = tp * tp;
    
    d = (d / 0.875 - SURFACE_FACTOR) / sc;
    
    d = smax(d, p.y - MAX_HEIGHT, 0.6);
    
    let camera_pos_xy = get_path(p.z / CAMERA_SPEED - CAMERA_TIME_OFFSET);
    let c = TUNNEL_RADIUS - length(p.xy - camera_pos_xy);
    
    d = smax(d, c, 0.75);
    
    return d;
}

fn grad(p: vec3f) -> vec3f {
    let e = 0.1;
    let d = map(p);
    return (d - vec3f(
        map(p - vec3f(e, 0.0, 0.0)),
        map(p - vec3f(0.0, e, 0.0)),
        map(p - vec3f(0.0, 0.0, e))
    )) / e;
}

fn get_voxel_pos(p: vec3f, s: f32) -> vec3f {
    return (floor(p / s) + 0.5) * s;
}

fn trace(ro: vec3f, rd: vec3f, tmax: f32) -> HitInfo {
    let s = VOXEL_SIZE;
    let sd = s * sqrt(3.0);
    
    let ird = 1.0 / rd;
    let iro = ro * ird;
    let srd = sign(ird);
    let ard = abs(ird);
    
    var t = 0.0;
    var vpos = get_voxel_pos(ro, s);
    var voxel = false;
    var vi = 0;
    var prd = vec3f(0.0);
    
    for (var i = 0; i < STEPS; i = i + 1) {
        let pos = ro + rd * t;
        let d = map(select(vpos, pos, voxel));
        
        if (!voxel) {
            t = t + d;
            if (d < sd) {
                vpos = get_voxel_pos(ro + rd * max(t - sd, 0.0), s);
                voxel = true;
                vi = 0;
            }
        } else {
            let n = (ro - vpos) * ird;
            let k = ard * s * 0.5;
            
            let t1 = -n - k;
            let t2 = -n + k;
            
            let tF = min(min(t2.x, t2.y), t2.z);
            
            let nrd = select(vec3f(0.0, 0.0, srd.z),
                             select(vec3f(0.0, srd.y, 0.0), vec3f(srd.x, 0.0, 0.0),
                                    t2.x <= t2.y && t2.x <= t2.z),
                             t2.y <= t2.z);
            
            if (d < 0.0) {
                return HitInfo(true, t, -prd, vpos, i);
            } else if (d > sd && vi > 2) {
                voxel = false;
                t = tF + sd;
                continue;
            }
            
            vpos = vpos + nrd * s;
            prd = nrd;
            t = tF + 1e-5; // Add epsilon to ensure boundary crossing
            vi = vi + 1;
        }
        
        if (t >= tmax || (rd.y > 0.0 && pos.y > MAX_HEIGHT)) {
            return HitInfo(false, 0.0, vec3f(0.0), vec3f(0.0), i);
        }
    }
    
    return HitInfo(false, 0.0, vec3f(0.0), vec3f(0.0), STEPS);
}

fn triplanar(p: vec3f, n: vec3f, k: f32, tex_index: i32) -> vec3f {
    let n_pow = pow(abs(n), vec3f(k));
    let n_norm = n_pow / dot(n_pow, vec3f(1.0));
    var col = vec3f(0.0);

    if (tex_index == 0) {
        // Assuming noise0_texture is 2D
        col = textureSample(noise0_texture, terrain_sampler, p.yz).rgb * n_norm.x +
              textureSample(noise0_texture, terrain_sampler, p.xz).rgb * n_norm.y +
              textureSample(noise0_texture, terrain_sampler, p.xy).rgb * n_norm.z;
    } else if (tex_index == 1) {
        // noise1_texture is 3D, sample with 3D coordinate
        let uvw = p * 0.08; // Adjust scale to match your usage
        let noise_val = textureSample(noise1_texture, terrain_sampler, uvw).r;
        col = vec3f(noise_val); // Convert scalar to grayscale vec3f
    } else if (tex_index == 2) {
        // Assuming grain_texture is 2D
        col = textureSample(grain_texture, terrain_sampler, p.yz).rgb * n_norm.x +
              textureSample(grain_texture, terrain_sampler, p.xz).rgb * n_norm.y +
              textureSample(grain_texture, terrain_sampler, p.xy).rgb * n_norm.z;
    } else if (tex_index == 3) {
        // Assuming dirt_texture is 2D
        col = textureSample(dirt_texture, terrain_sampler, p.yz).rgb * n_norm.x +
              textureSample(dirt_texture, terrain_sampler, p.xz).rgb * n_norm.y +
              textureSample(dirt_texture, terrain_sampler, p.xy).rgb * n_norm.z;
    }

    return col;
}

fn getBiome(pos: vec3f) -> vec2f {
    let snow = textureSample(dirt_texture, terrain_sampler, pos.xz * 0.00015).r;
    let snow_smooth = smoothstep(0.695, 0.7, snow);
    
    let desert = textureSample(dirt_texture, terrain_sampler, vec2f(0.55) - pos.zx * 0.00008).g;
    let desert_smooth = smoothstep(0.67, 0.672, desert);
    
    return vec2f(desert_smooth, snow_smooth);
}

fn getAlbedo(vpos: vec3f, gn: vec3f, lod: f32) -> vec3f {
    var alb = vec3f(1.0) - triplanar(vpos * 0.08, gn, 4.0, 2); // iChannel2: grain
    alb = alb * alb;
    
    var alb2 = vec3f(1.0) - triplanar(vpos * 0.08, gn, 4.0, 3); // iChannel3: dirt
    alb2 = alb2 * alb2;
    
    let k = triplanar(vpos * 0.0005, gn, 4.0, 0).r; // iChannel0: noise0
    let k_smooth = smoothstep(0.3, 0.25, k);
    
    let wk = smoothstep(MAX_WATER_HEIGHT, MAX_WATER_HEIGHT + 0.5, vpos.y);
    let top = smoothstep(0.3, 0.7, gn.y);
    
    alb = alb * 0.95 * vec3f(1.0, 0.7, 0.65) + 0.05;
    alb = mix(alb, alb2 * vec3f(0.55, 1.0, 0.1), top * wk);
    
    alb = mix(alb, smoothstep(vec3f(0.0), vec3f(1.0), alb2), k_smooth * (1.0 - top));
    
    let biome = getBiome(vpos);
    
    var snow = alb2 * 0.8 + 0.2 * vec3f(0.25, 0.5, 1.0);
    snow = mix(snow, vec3f(0.85, 0.95, 1.0), top * wk * 0.5);
    
    alb = mix(alb, clamp(vec3f(1.0, 0.95, 0.9) - alb2 * 0.65, vec3f(0.0), vec3f(1.0)), biome.x);
    alb = mix(alb, snow * 2.0, biome.y);
    
    var dcol = vec3f(0.8, 0.55, 0.35);
    dcol = mix(dcol, vec3f(0.8, 0.65, 0.4), biome.x);
    dcol = mix(dcol, vec3f(0.2, 0.6, 0.8), biome.y);
    
    alb = mix(alb, alb * dcol, (1.0 - wk) * mix(1.0 - k_smooth, 1.0, max(biome.x, biome.y)));
    
    return alb;
}

fn shade(pos: vec3f, ldir: vec3f, lod: f32, hit: HitInfo) -> vec3f {
    let vpos = hit.id;
    
    let g = grad(vpos);
    let gd = length(g);
    let gn = g / gd;
    let n = hit.n;
    
    var dif = max(dot(n, ldir), 0.0);
    
    if (dif > 0.0) {
        let pos_shadow = pos + n * 0.001; // Hybrid traversal offset
        let hitL = trace(pos_shadow, ldir, 12.0);
        if (hitL.is_hit) {
            dif = 0.0;
        }
    }
    
    var col = getAlbedo(vpos, gn, lod);
    
    let ao = smoothstep(-0.08, 0.04, map(pos) / length(grad(pos)));
    let hao = smoothstep(WATER_HEIGHT - 12.0, WATER_HEIGHT, pos.y);
    
    col = col * dot(abs(n), vec3f(0.8, 1.0, 0.9)); // Hybrid traversal adjustment
    col = col * (dif * 0.6 + 0.4) * lcol;
    col = col * (ao * 0.6 + 0.4);
    col = col * (hao * 0.6 + 0.4);
    
    return col;
}

fn getSky(rd: vec3f) -> vec3f {
    let skyCol = vec3f(0.353, 0.611, 1.0);
    let skyCol2 = vec3f(0.8, 0.9, 1.0);
    var col = mix(skyCol2, skyCol, smoothstep(0.0, 0.2, rd.y)) * 1.2;
    
    const sunAngleDegrees: f32 = 0.52;
    const sunAngle: f32 = sunAngleDegrees * PI / 180.0;
    const sunCost: f32 = cos(sunAngle);
    
    let cost = max(dot(rd, normalize(ldir_unnormalized)), 0.0);
    let dist = cost - sunCost;
    
    // let bloom = max(1.0 / (0.02 - min(dist, 0.0) * 500.0), 0.0) * 0.02;
    // let sun = 10.0 * lcol * (step(0.0, dist) + bloom);
    let sun = 100.0 * lcol * (step(0.0, dist));
    
    return col + sun;
}

// Vertex shader
@vertex
fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
    let positions = array<vec2<f32>, 4>(
        vec2<f32>(-1.0, -1.0),
        vec2<f32>(1.0, -1.0),
        vec2<f32>(-1.0, 1.0),
        vec2<f32>(1.0, 1.0)
    );
    
    let tex_coords = array<vec2<f32>, 4>(
        vec2<f32>(0.0, 0.0),
        vec2<f32>(1.0, 0.0),
        vec2<f32>(0.0, 1.0),
        vec2<f32>(1.0, 1.0)
    );

    var output: VertexOutput;
    output.position = vec4<f32>(positions[vertex_index], 0.0, 1.0);
    output.tex_uv = tex_coords[vertex_index];
    output.normal = vec3f(0.0, 0.0, 1.0);
    output.world_position = vec3f(0.0);
    
    return output;
}

// Fragment shader
@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4f {
    let ro = camera.camera_position;
    let ndc = vec4f(input.tex_uv * 2.0 - 1.0, 1.0, 1.0);
    let world_pos = camera.inv_view_proj * ndc;
    let world_pos_normalized = world_pos.xyz / world_pos.w;
    let rd = normalize(world_pos_normalized - ro);
    
    let tmax = MAX_DIST;
    let hit = trace(ro, rd, tmax);
    var col = vec3f(0.0);
    
    if (hit.is_hit) {
        let pos = ro + rd * hit.t;
        let lod = clamp(log2(distance(ro, hit.id)) - 2.0, 0.0, 6.0);
        col = shade(pos, normalize(ldir_unnormalized), lod, hit);
        
        let a = 0.012;
        let b = 0.08;
        let fog = (a / b) * exp(-(ro.y - WATER_HEIGHT) * b) * (1.0 - exp(-hit.t * rd.y * b)) / max(rd.y, EPS);
        let biome = getBiome(hit.id);
        let fogCol = mix(vec3f(0.5, 0.8, 1.0), vec3f(1.0, 0.85, 0.6), biome.x);
        col = mix(col, fogCol, clamp(fog, 0.0, 1.0));
    } else {
        col = getSky(rd);
    }
    
    // Simplified water effect (optional full implementation below)
    let pt = -(ro.y - WATER_HEIGHT) / max(rd.y, EPS);
    var dist = 1.0f;
    if hit.is_hit {
        dist = hit.t;
    } else {
        dist =  MAX_DIST;
    }
    if (pt > 0.0 && (pt < dist || ro.y < WATER_HEIGHT)) {
        let wpos = ro + rd * pt;
        let biome = getBiome(wpos);
        var wcol = vec3f(0.5, 1.0, 1.0);
        wcol = mix(wcol, vec3f(0.5, 1.0, 0.9), biome.x);
        wcol = mix(wcol, vec3f(0.2, 0.8, 1.0), biome.y);
        col = mix(col, wcol, 0.5); // Simplified blending
    }
    
    return vec4f(col, 1.0);
}